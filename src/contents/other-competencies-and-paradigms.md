---
slug: "/other-competencies-and-paradigms"
date: "2024-12-27"
title: "기타 기술 및 패러다임"
origin: "https://frontendmasters.com/guides/front-end-handbook/2024/#2"
---

# 6. 기타 기술 및 패러다임

본 섹션은 프론트엔드 개발자에게 필요한 다른 기술과 패러다임을 소개하고 설명합니다.

## 6.1 A/B 테스트

A/B 테스트(혹은 스플릿split 테스트)는 웹 페이지, 앱 기능 또는 다른 제품 요소의 두 가지 버전을 비교하여 어느 것이 더 잘 작동하는지 결정하는 방법입니다. 이 과정은 특히 웹 사이트나 애플리케이션에서 사용자 경험과 참여도를 최적화하는데 중요합니다.

A/B 테스트는 다음의 단계를 포함합니다:

- 가설 설정: 변화가 특정 지표를 어떻게 향상시킬 수 있을지에 대해 가설을 설정합니다.
- 변형 생성: 원본과 변형된 두 가지 버전이 만들어집니다.
- 무작위 실험: 대상을 무작위로 두 그룹으로 나누어 각 버전을 실험합니다.
- 데이터 수집: 두가지 버전의 사용자 행동 데이털를 수집합니다.
- 데이터 분석: 두 버전의 결과를 비교하여 더 잘 작동하는 버전을 파악합니다.
- 결론 도출: 분석에 기반하여 더 우수한 버전을 결정합니다.
- 구현: 모든 사용자에게 우수한 버전이 적용됩니다.

A/B 테스트는 데이터 기반 의사 결정을 가능하게 하며, 사용자 인터페이스와 경험을 개선하는데 효과적이고 더 높은 유저 만족도와 웹 퍼포먼스를 이끌어냅니다.

## 6.2 AI 기반 코딩 도구

AI 기반 코딩 도구는 인공지능(AI)과 머신러닝(ML)을 활용하여 개발자가 코드를 작성하는 데 도움을 주는 소프트웨어 프로그램입니다. 이러한 도구는 반복적인 작업을 자동화하고 지능적으로 코드를 추천하여 개발자의 생산성과 효율성을 향상시키기 위해 설계되었습니다. 코드 자동 완성, 리팩토링, 디버깅 등 다양한 용도로 활용될 수 있습니다.

AI 기반 코딩 도구는 개발자 커뮤니티에서 점점 더 인기를 얻고 있으며, 많은 통합 개발 환경(IDE)과 코드 편집기에 이러한 기능이 통합되고 있습니다. 특히 프론트엔드 개발자에게 유용한데, HTML, CSS, JavaScript 코드를 작성하는 작업을 지원할 수 있습니다. 또한 코드 리팩토링이나 디버깅 같은 더 복잡한 작업에도 활용될 수 있습니다.

AI 기반 코딩 도구는 아직 초기 단계에 있으며, 그 기능은 제한적입니다. 하지만 앞으로 개발자의 생산성과 효율성을 크게 향상시킬 잠재력을 가지고 있습니다.

더 학습하기
- [GitHub Copilot in VS Code](https://code.visualstudio.com/docs/copilot/overview)

도구 
- [Github Copilot](https://github.com/features/copilot)

## 6.3 적응형 디자인

## 6.4 알고리즘

## 6. 비동기 프로그래밍

## 6.6 아토믹 CSS

## 6.7 백엔드 서비스 (BaaS)

## 6.8 빅 O 표기법

## 6.9 빌드 (웹 번들러)

## 6.10 CI/CD

## 6.11

## 6.12

## 6.13 코드 커버리지

코드 커버리지는 소프트웨어 테스트에서 프로그램의 소스 코드가 테스트 중에 얼마나 많이 실행되었는지를 측정하는 중요한 지표입니다. 이는 코드베이스에서 테스트되지 않은 부분을 식별하고, 중요한 기능이 철저히 테스트되었는지 확인하는 데 중요합니다. 주요 코드 커버리지 유형에는 Statement 커버리지, Branch 커버리지, Functional 커버리지 및 Condition 커버리지가 있으며, 각각은 실행할 수 있는 문장, 제어 구조의 분기, 함수 호출 맟 불린 하위 표현식 등의 다른 측면에 집중합니다.

실제로는 프로그래밍 언어에 특화된 도구(JavaScript의 Istanbul)는 테스트가 실행되는 동안 코드의 부분을 추적하고 상세한 보고서를 생성합니다. 높은 코드 커버리지는 철저한 테스트를 나타내지만, 에러를 완전히 방지할 수 있다는 보장은 아닙니다. 현실적인 커버리지 목표를 정하고 주요 기능에 우선순위를 두는 것이 중요합니다. 또한, 특히 프론트엔드 개발에서는 일부 코드가 포괄적으로 테스트하기 어려울 수 있음을 유의해야 합니다. 코드 커버리지는 전반적인 소프트웨어의 품질을 평가하는 지표 중 하나로 사용되어야 합니다.

더 학습하기

- [Enterprise UI Development: Testing & Code Quality](https://frontendmasters.com/courses/enterprise-ui-dev/?utm_source=guides&utm_medium=website&utm_campaign=feh2024) (Code Coverage Section) from Frontend Masters

## 6.14

## 6.15 CSS in JS

CSS in JS는 최신 웹 개발에서 사용되는 스타일링 기법으로, 특히 JavaScript 기반의 UI 프레임워크나 라이브러리와 함께 자주 사용됩니다. 이 방식은 CSS 스타일을 JavaScript 코드 안에 직접 작성하는 것을 의미하며, UI 컴포넌트 기반 아키텍처에서 여러 가지 이점을 제공합니다.

장점 : 
- **로컬 스코프(Local Scoping)**: 스타일이 컴포넌트 단위로 범위가 제한되어 있어, 전역 CSS 충돌을 방지할 수 있습니다.
- **동적 스타일링(Dynamic Styling)**: 컴포넌트의 상태(state)나 props에 따라 동적으로 스타일을 변경하기 쉽습니다.
- **JavaScript 기능 활용**: 변수, 함수, 조건문 등 JavaScript의 기능을 스타일링에 적극적으로 활용할 수 있습니다.
- **유지보수성(Maintenance)**: 스타일을 컴포넌트와 가까운 위치에 작성함으로써, 대규모 코드베이스에서 유지보수가 쉬워집니다.

고려할 점 : 
- **성능(Performance)**: 일부 상황에서는 JavaScript 기반 스타일링이 성능에 영향을 줄 수 있습니다.
- **복잡성(Complexity)**: JavaScript에 익숙하지 않은 사람들에게는 추가적인 복잡함을 가져올 수 있습니다.
- **서버 사이드 렌더링(SSR)**: 일부 CSS-in-JS 솔루션은 서버 사이드 렌더링 환경에서 설정이 복잡할 수 있습니다.

CSS in JS는 스타일링을 현대적인 JavaScript 및 컴포넌트 기반 프레임워크와 일치시키며, 캡슐화되고 확장 가능한 스타일링 솔루션을 제공합니다.

도구
- [Styled Components](https://styled-components.com/)
- [CSS Modules](https://github.com/css-modules/css-modules)
- [Panda CSS](https://panda-css.com/)
- [StyleX](https://stylex-docusaurus.vercel.app/docs/learn/)
- [Vanilla Extract](https://vanilla-extract.style/)

## 6.16 CSS Animations

CSS 애니메이션은 웹 개발에서 강력한 도구로, 사용자와의 상호작용을 돕고 웹 페이지를 더욱 생동감 있게 만들어줍니다. HTML 요소와 CSS 속성에 애니메이션을 적용할 수 있어, 웹 페이지에 다양한 시각적 효과를 더할 수 있습니다. 특히, 호버 효과나 전환(transition)과 같은 상태 기반 애니메이션을 구현할 때 유용합니다.

CSS 애니메이션 개요 : 
- **간편함과 성능**:간단한 애니메이션을 구현하기 쉽고, 기본적인 전환 효과에서는 성능이 뛰어납니다.

- **문법(Syntax)**: @keyframes와 animation 속성을 사용해 CSS만으로 애니메이션을 정의합니다.

- **제어(Control)**:비교적 제어가 제한적이지만, 상태 기반의 간단한 애니메이션(예: 호버 효과, 전환 효과)에는 이상적입니다.

- **한계(Limitations)**:사용자 입력에 따라 동적으로 반응해야 하는 복잡한 인터랙티브 애니메이션에는 적합하지 않습니다.

더 학습하기

- [Using CSS animations on MDN]()
- [CSS Animations and Transitions from Frontend Masters]()

주요 도구들
- [Animista](https://animista.net/)
- [Animate.css](https://animate.style/)


## 6.17

## 6.18

## 6.19

## 6.21

## 6.22

## 6.23

## 6.24

## 6.25

## 6.26

## 6.27

## 6.28

## 6.29

## 6.30

## 6.31 GraphQL

GraphQL은 쿼리 언어이며, 해당 쿼리로 기존 데이터를 가져오는 실행 시스템입니다. 이것은 전통적인 REST API 접근과는 다릅니다. REST에서는 보통 다른 데이터 요청을 처리하는 여러 엔드포인트를 사용하지만, GraphQL은 단 하나의 엔드포인트를 갖습니다. 이것은 데이터 검색을 더 효율적이고 유연하게 만듭니다.

GraphQL을 사용하면, 필요한 것을 더 많거나 더 적지도 않게 정확히 요청할 수 있습니다. 이는 REST API를 사용하면 종종 마주치는 과도한 데이터 요청(over-fetching)이나 부족한 데이터 요청(under-fetching)을 피할 수 있음을 뜻합니다. 예를 들어, 만약 유저의 이름과 이메일만 필요하다면, REST API에서는 전체 사용자 객체를 검색했던 것과 달리 하나의 쿼리 안에 이것들을 구체적으로 요청할 수 있습니다.

다른 주요 포인트는 강력한 타입시스템입니다. 데이터의 타입을 정의하면 이 타입들은 요청한 쿼리와 뮤테이션(데이터 변화를 위한 수행)이 유효함을 보장합니다. 이것은은 특히 동적 데이터와 작업하는 프론트엔드 개발에 매우 유용합니다. 이는 당신이 얻은 데이터가 예상한 것과 일치하다는 것을 보장하여 버그를 줄이고, 데이터 처리 방식을 단순화합니다.

GraphQL은 또한 프론트엔드 개발자와 백엔드 개발자 사이의 협력적인 환경을 촉진합니다. 이용한 데이터의 명확한 구조를 제공하기 때문에 양 측에서 활용할 수 있습니다. GraphiQL(GraphQL을 탐색하는 브라우저 통합 환경)과 같은 수단은 쿼리를 쉽게 테스트하고 구조화하는 것을 지원합니다.

하지만, 완벽하지는 않습니다. 쿼리와 뮤테이션을 구조화하는 방법을 이해하는데 러닝커브가 있습니다. 또한 REST와 다른 캐싱과 상태 관리가 필요합니다. 그러나 전반적으로, 정확한 데이터패칭과 중복 코드 감소로 데이터 검색에 더 많은 제어가 필요한 복잡한 애플리케이션에서 인기를 끌고 있습니다.

더 학습하기:

- [GraphQL 공식문서](https://graphql.org/learn/)
- [Sever-Side GraphQL in Node.js 강좌(Frontend Masters)](https://frontendmasters.com/courses/server-graphql-nextjs/)
- [Client-Side GraphQL in Node.js 강좌(Frontend Masters)](https://frontendmasters.com/courses/server-graphql-nextjs/)
- [GraphQL 튜토리얼](https://www.howtographql.com/)

## 6.32

## 6.33

## 6.34

## 6.35

## 6.36

## 6.37

## 6.38

## 6.39

## 6.40 모노레포

모노레포(Monorepo)는 monolithic repository의 약자로, 여러 프로젝트의 코드가 하나의 버전 관리 저장소에 저장되는 소프트웨어 개발 전략입니다. 이는 각 프로젝트나 서비스가 자체적인 저장소를 가지는 멀티레포 접근법과 대조적입니다. 다음은 모노레포의 주요 특징들입니다:

- 단일 진실 공급원(Single Source of Truth, SSoT): 다른 프로젝트, 라이브러리 및 서비스의 모든 코드를 하나의 장소에서 관리합니다. 이는 의존성을 관리하는 과정과 전체 코드베이스를 이해하기 쉽게 합니다.
- 단순화된 의존성 관리: 모노레포에서는 레포지토리 내의 모든 프로젝트에서 공유 코드와 라이브러리에 쉽게 접근 가능합니다. 이는 의존성과 버전 관리를 단일화하여 복잡성을 줄여줍니다.
- 통합된 빌드 및 테스트 시스템: 모노레포는 모든 프로젝트에 일관된 도구를 사용할 수 있게 합니다. 빌드, 테스트, 배포 과정을 표준화하여 시스템을 유지보수하고 확장하는 것이 용이해집니다.
- 쉬운 리팩토링 및 코드 재사용: 모든 프로젝트가 동일한 저장소에 있기 때문에 코드를 리팩토링하거나 다른 팀과 프로젝트 간에 코드를 쉽게 재사용할 수 있습니다. 이는 개발 효율성을 높이고 중복된 작업을 줄이는 데 도움이 됩니다.
- 원자적(atomic) 커밋: 여러 프로젝트에 걸친 변경 사항을 원자적으로 함께 커밋할 수 있습니다. 이를 통해 시스템의 모든 부분이 항상 동기화 상태를 유지하며 의존성을 깨뜨릴 위험을 줄입니다.
- 협업 향상: 모노레포는 팀의 협업을 촉진할 수 있습니다. 코드베이스가 하나의 저장소에 있기 때문에 더 많은 부분을 변경할 가능성이 높습니다.
- 도전: 하지만 모노레포에는 몇가지 도전과제도 있습니다. 저장소가 매우 커지면 버전 관리 시스템에 문제를 일으키거나 느린 빌드 타임을 가져올 수 있습니다. 따라서 모노레포의 규모를 처리할 수 있는 강력한 도구와 인프라가 필요합니다.

Google, Facebook 및 Twitter와 같은 회사들은 도전과제에도 불구하고 그 이점 때문에 큰 규모의 소프트웨어 규모를 위해 모노레포를 사용합니다. 프론트엔드 엔지니어로서의 역할은, 여러 개의 상호 연관된 프로젝트를 작업하고 있고 의존성 관리와 테트스 과정을 단순화하고자 한다면, 모노레포가 유용할 수 있습니다. 그러나 모노레포 사용 여부는 프로젝트의 특정 요구사항과 규모에 따라 결정해야 합니다.

더 학습하기:

- [Monorepos.tools(영어)](https://monorepo.tools/)
- [JavaScript와 TypeScript 모노레포](https://frontendmasters.com/courses/monorepos/?utm_source=guides&utm_medium=website&utm_campaign=feh2024) on Frontend Masters

## 6.41 다중 페이지 애플리케이션(MPA)

## 6.42 웹 기술을 활용한 네이티브 애플리케이션 개발

## 6.43 객체 지향 프로그래밍(Object Oriented Programming, OOP)

## 6.44 오프라인/로컬 우선 웹 개발

## 6.45 폴리필

## 6.46 프로그레시브 웹 앱 (PWA)

## 6.47 정규 표현식

## 6.48 반응형 디자인(RWD)

## 6.49 REST API

## 6.50 검색엔진 최적화

## 6.51

## 6.52 시맨틱 HTML

## 6.53 서버 사이드 렌더링(SSR)

## 6.54 단일 페이지 애플리케이션

## 6.55

## 6.56

## 6.57

## 6.58 정적 분석 도구

## 6.59 정적 사이트 생성기(SSG)

## 6.60 스트리밍 SSR

## 6.61 트리 및 그래프 데이터 구조

## 6.62 UI 디자인 패턴

## 6.63 UI 툴킷/라이브러리(자바스크립트 UI 위젯 등)

## 6.64 유닛 테스트

## 6.65 사용자 경험(UX)

## 6.66 유틸리티 퍼스트 CSS 프레임워크

## 6.67 가상 DOM

## 6.68 시각적 테스트

## 6.69 웹 1.0

## 6.70 웹 2.0

## 6.71 웹 3.0(개념적)

## 6.72 웹 애니메이션(자바스크립트 애니메이션 등)

## 6.73 웹 어셈블리(WASM)

## 6.74 웹 브라우저 테스팅

## 6.75 웹 컴포넌트

## 6.76 웹 폰트

## 6.77 웹 호스팅 서비스

## 6.78 웹 성능

## 6.79 웹 보안

## 6.80 웹 소켓

## 6.81 웹 타이포그래피(Web Typography)

## 6.82 웹 워커(Web Workers)

## 6.83 와이어프레임

"콘텐츠 관리 시스템 (CMS)",
"코드 복잡도",
"코드 커버리지",
"코드 포매터",
"CSS in JS",
"CSS 애니메이션",
"CSS 프레임워크",
"CSS 리셋",
"데이터 API 테스트",
"데이터 구조",
"선언적 프로그래밍",
"디자인 시스템",
"디바이스 테스트",
"개발 서버",
"에뮬레이션을 통한 디바이스 테스트",
"DOM 스크립팅/조작",
"프론트엔드 웹 개발 프레임워크 및 라이브러리",
"풀 스택 웹 개발 프레임워크",
"함수형 프로그래밍 (FP)",
"함수형/전체 테스트",
"헤드리스 CMS",
"HTML 이메일 개발",
"명령형 프로그래밍",
"상호작용 디자인",
"JAM 스택",
"자바스크립트 성능",
"JSX",
"마이크로 프론트엔드",
"다중 페이지 애플리케이션 (MPA)",
"웹 기술을 통한 네이티브 애플리케이션 개발",
"객체지향 프로그래밍 (OOP)",
"오프라인/로컬 우선 웹 개발",
"폴리필",
"",
"정규 표현식",
"반응형 디자인 (RWD)",
"REST API",
"검색 엔진 최적화 (SEO)",
"의미론적 버전 관리",
"의미론적 HTML",
"서버 사이드 렌더링 (SSR)",
"싱글 페이지 애플리케이션 (SPA)",
"상태 및 상태 관리",
"트리 및"상태 기계",
"정적 분석 도구",
"정적 사이트 생성기 (SSG)",
"정적 타입 / 타입 주석",
"스트리밍 SSR",
그래프 데이터 구조",
"UI 디자인 패턴",
"UI 툴킷/라이브러리 (자바스크립트 UI 위젯)",
"유닛 테스트",
